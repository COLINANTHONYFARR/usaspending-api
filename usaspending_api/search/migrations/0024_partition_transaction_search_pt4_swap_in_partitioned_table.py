# Generated by Django 3.2.15 on 2023-02-17 19:13
from django.core.management import call_command
from django.db import migrations, models, connection


def swap_partitioned_table_with_partitions(apps, _):
    # Swap partitions first, then partition table
    call_command("swap_in_new_table", "--table=transaction_search_fabs", "--keep-old-data")
    call_command("swap_in_new_table", "--table=transaction_search_fpds", "--keep-old-data")
    call_command("swap_in_new_table", "--table=transaction_search", "--keep-old-data")


def undo_swap_partitioned_table_with_partitions(apps, _):
    # Do it in the same order as swapped (partitions first, then partitioned table)
    # Otherwise when cleanup of the "old" partitioned table deletes it,
    # it will cascade-delete its partitions, and prevent "un-swapping" them

    # Detach partitions before swapping out
    with connection.cursor() as cursor:
        cursor.execute(f"ALTER TABLE rpt.transaction_search DETACH PARTITION rpt.transaction_search_fabs")
        call_command("swap_in_new_table", "--table=transaction_search_fabs", "--undo")
        cursor.execute(f"ALTER TABLE rpt.transaction_search DETACH PARTITION rpt.transaction_search_fpds")
        call_command("swap_in_new_table", "--table=transaction_search_fpds", "--undo")
        call_command("swap_in_new_table", "--table=transaction_search", "--undo")

class Migration(migrations.Migration):
    # Subsequent steps use a different connection than the one running migrations, so in order to see tables or DB
    # objects being created or dropped by prior steps, the migration steps need to be made non-atomic
    atomic = False

    dependencies = [
        ("search", "0023_partition_transaction_search_pt3_copy_metadata"),
    ]

    operations = [
        # STEP 1: Align constraints between tables to be swapped.
        migrations.RunSQL(
            sql="""
                ALTER TABLE rpt.transaction_search DROP CONSTRAINT IF EXISTS transaction_search_pkey;
                DROP INDEX IF EXISTS rpt.transaction_search_pkey;
            """,
            reverse_sql="""
                CREATE UNIQUE INDEX IF NOT EXISTS transaction_search_pkey ON rpt.transaction_search(transaction_id int8_ops);
            """,
        ),
        # STEP 2: Swap the partitions with data into the rpt schema in place of the empty/placeholder partitions
        #         This needs to be done as one Python function, so that if needing to be reversed, it can be called
        #         in reverse order.
        migrations.RunPython(
            code=swap_partitioned_table_with_partitions,
            reverse_code=undo_swap_partitioned_table_with_partitions,
        ),
    ]
